testing the scriptormat_minor":0,"metadata":{"colab":{"name":"Modified_Claptcha_Lib.ipynb","version":"0.3.2","views":{},"default_view":{},"provenance":[]},"kernelspec":{"display_name":"Python 3","language":"python","name":"python3"}},"cells":[{"metadata":{"id":"TcgTkNmuGBIC","colab_type":"code","colab":{"autoexec":{"startup":false,"wait_interval":0},"base_uri":"https://localhost:8080/","height":35},"outputId":"4e413138-9fbe-4338-8ac2-6d4f6e75bb79","executionInfo":{"status":"ok","timestamp":1531409235357,"user_tz":-480,"elapsed":2069,"user":{"displayName":"2017 Poon Zong Wei Julian","photoUrl":"https://lh3.googleusercontent.com/a/default-user=s128","userId":"104806765094541702931"}}},"cell_type":"code","source":["### Generates (3) Claptcha images (modified) for each letter, each 20x20. To change number of Claptcha images per letter, {ctrl+F, type 9908}\n","\n","import sys\n","import os\n","import random\n","from functools import wraps\n","from io import BytesIO\n","from PIL import Image, ImageDraw, ImageFont\n","import cv2\n","import numpy\n","\n","##########################################################################################################\n","##########################################################################################################\n","##########################################################################################################\n","#################################### Clapcha Library starts ##############################################\n","##########################################################################################################\n","##########################################################################################################\n","##########################################################################################################\n","\n","class ClaptchaError(Exception):\n","    \"\"\"Exception class for Claptcha errors.\"\"\"\n","\n","    pass\n","\n","\n","class Claptcha(object):\n","    r\"\"\"\n","    Claptcha class.\n","    Claptcha can be use to create PIL Images, BytesIO objects and image\n","    files with CAPTCHA messages. User has to provide at least a source\n","    (a string containing text used in CAPTCHA image or a callable object\n","    returning a string) and a filepath to TTF font file.\n","    Additionally, Claptcha allows to define image size and estimated\n","    margins, used in automatically calculating font size. By default,\n","    Claptcha generates a PNG image using bicubic resampling filter\n","    (configurable).\n","    Optionally, user can define white noise, making it less readable for\n","    OCR software. However, this significantly extends execution time of\n","    image creation.\n","    \"\"\"\n","\n","    def __init__(self, source, font,\n","                 size=(20, 20), margin=(3, 3),\n","                 **kwargs):\n","        r\"\"\"\n","        Claptcha object init.\n","        Claptcha object requires at least a text source (a string or a\n","        callable object returning a string) and a path to a TTF file. Both\n","        are used in generating text in returned CAPTCHA image with a given\n","        font. Callable object allow for creating variable CAPTCHAs without\n","        redeclaring Claptcha instance, e.g. a randomized stream of characters\n","        :param source:\n","            String or a callable object returning a string.\n","        :param font:\n","            Valid path (relative or absolute) to a TTF file.\n","        :param size:\n","            A pair with CAPTCHA size (width, height)\n","            in pixels.\n","        :param margin:\n","            A pair with CAPTCHA x and y margins in pixels\n","            Note that generated text may slightly overlap\n","            given margins, you should treat them only as\n","            an estimate.\n","        :param \\**kwargs:\n","            See below\n","        :Keyword Arguments:\n","            * *format* (``string``) --\n","              Image format acceptable by Image class from PIL package.\n","            * *resample* (``int``) --\n","              Resampling filter. Allowed: Image.NEAREST, Image.BILINEAR and\n","              Image.BICUBIC. Default: Image.BILINEAR.\n","            * *noise* (``float``) --\n","              Parameter from range [0,1] used in creating noise effect in\n","              CAPTCHA image. If not larger than 1/255, no noise if generated.\n","              It is advised to not use this option if you want to focus on\n","              efficiency, since generating noise can significantly extend\n","              image creation time. Default: 0.\n","        \"\"\"\n","        self.source = source\n","        self.size = size\n","        self.margin = margin\n","        self.font = font\n","\n","        self.format = kwargs.get('format', 'PNG')\n","        self.resample = kwargs.get('resample', Image.BILINEAR)\n","        self.noise = abs(kwargs.get('noise', 0.))\n","\n","    @property\n","    def image(self):\n","        r\"\"\"\n","        Tuple with a CAPTCHA text and a Image object.\n","        Images are generated on the fly, using given text source, TTF font and\n","        other parameters passable through __init__. All letters in used text\n","        are morphed. Also a line is morphed and pased onto CAPTCHA text.\n","        Additionaly, if self.noise > 1/255, a \"snowy\" image is merged with\n","        CAPTCHA image with a 50/50 ratio.\n","        Property returns a pair containing a string with text in returned\n","        image and image itself.\n","        :returns: ``tuple`` (CAPTCHA text, Image object)\n","        \"\"\"\n","        text = self.text\n","        w, h = self.font.getsize(text)\n","        margin_x = round(self.margin_x * w / self.w)\n","        margin_y = round(self.margin_y * h / self.h)\n","\n","        image = Image.new('RGB',\n","                          (w + 2*margin_x, h + 2*margin_y),\n","                          (255, 255, 255))\n","\n","        # Text\n","        self._writeText(image, text, pos=(margin_x, margin_y))\n","\n","\n","        # White noise\n","        noise = self._whiteNoise(image.size)\n","        if noise is not None:\n","            image = Image.blend(image, noise, 0.5)\n","\n","        # Resize\n","        image = image.resize(self.size, resample=self.resample)\n","\n","        return (text, image)\n","\n","    @property\n","    def bytes(self):\n","        r\"\"\"\n","        Tuple with a CAPTCHA text and a BytesIO object.\n","        Property calls self.image and saves image contents in a BytesIO\n","        instance, returning CAPTCHA text and BytesIO as a tuple.\n","        See: image.\n","        :returns: ``tuple`` (CAPTCHA text, BytesIO object)\n","        \"\"\"\n","        text, image = self.image\n","        bytes = BytesIO()\n","        image.save(bytes, format=self.format)\n","        bytes.seek(0)\n","        return (text, bytes)\n","\n","    def write(self, file):\n","        r\"\"\"\n","        Save CAPTCHA image in given filepath.\n","        Property calls self.image and saves image contents in a file,\n","        returning CAPTCHA text and filepath as a tuple.\n","        See: image.\n","        :param file:\n","            Path to file, where CAPTCHA image will be saved.\n","        :returns: ``tuple`` (CAPTCHA text, filepath)\n","        \"\"\"\n","        text, image = self.image\n","        image.save(file, format=self.format)\n","        return (text, file)\n","\n","    @property\n","    def source(self):\n","        \"\"\"Text source, either a string or a callable object.\"\"\"\n","        return self.__source\n","\n","    @source.setter\n","    def source(self, source):\n","        if not (isinstance(source, str) or callable(source)):\n","            raise ClaptchaError(\"source has to be either a string or be callable\")\n","        self.__source = source\n","\n","    @property\n","    def text(self):\n","        \"\"\"Text received from self.source.\"\"\"\n","        if isinstance(self.source, str):\n","            return self.source\n","        else:\n","            return self.source()\n","\n","    def _with_pair_validator(func):\n","        @wraps(func)\n","        def wrapper(inst, pair):\n","            if not (hasattr(pair, '__len__') and hasattr(pair, '__getitem__')):\n","                raise ClaptchaError(\"Sequence not provided\")\n","            if len(pair) != 2:\n","                raise ClaptchaError(\"Sequence has to have exactly 2 elements\")\n","            return func(inst, pair)\n","        return wrapper\n","\n","    @property\n","    def size(self):\n","        \"\"\"CAPTCHA image size.\"\"\"\n","        return self.__size\n","\n","    @size.setter\n","    @_with_pair_validator\n","    def size(self, size):\n","        self.__size = (int(size[0]), int(size[1]))\n","\n","    @property\n","    def w(self):\n","        \"\"\"CAPTCHA image width.\"\"\"\n","        return self.size[0]\n","\n","    @property\n","    def h(self):\n","        \"\"\"CAPTCHA image height.\"\"\"\n","        return self.size[1]\n","\n","    @property\n","    def margin(self):\n","        \"\"\"CAPTCHA image estimated margin.\"\"\"\n","        return self.__margin\n","\n","    @margin.setter\n","    @_with_pair_validator\n","    def margin(self, margin):\n","        if 2*margin[1] > self.h:\n","            raise ClaptchaError(\"Margin y cannot be larger than half of image height.\")\n","        self.__margin = (int(margin[0]), int(margin[1]))\n","\n","    @property\n","    def margin_x(self):\n","        \"\"\"CAPTCHA image estimated x margin.\"\"\"\n","        return self.__margin[0]\n","\n","    @property\n","    def margin_y(self):\n","        \"\"\"CAPTCHA image estimated y margin.\"\"\"\n","        return self.__margin[1]\n","\n","    def _with_file_validator(func):\n","        @wraps(func)\n","        def wrapper(inst, file):\n","            if not isinstance(file, ImageFont.ImageFont):\n","                if not os.path.exists(file):\n","                    raise ClaptchaError(\"%s doesn't exist\" % (file,))\n","                if not os.path.isfile(file):\n","                    raise ClaptchaError(\"%s is not a file\" % (file,))\n","            return func(inst, file)\n","        return wrapper\n","\n","    @property\n","    def font(self):\n","        \"\"\"ImageFont object from PIL package.\"\"\"\n","        return self.__font\n","\n","    @font.setter\n","    @_with_file_validator\n","    def font(self, font):\n","        if isinstance(font, ImageFont.ImageFont):\n","            self.__font = font\n","        else:\n","            fontsize = self.h - 2 * self.margin_y\n","            self.__font = ImageFont.truetype(font, fontsize)\n","\n","    @property\n","    def noise(self):\n","        \"\"\"Noise parameter from [0,1].\"\"\"\n","        return self.__noise\n","\n","    @noise.setter\n","    def noise(self, noise):\n","        if noise < 0. or noise > 1.:\n","            raise ClaptchaError(\"only acceptable noise amplitude from range [0:1]\")\n","        self.__noise = noise\n","\n","    def _writeText(self, image, text, pos):\n","        \"\"\"Write morphed text in Image object.\"\"\"\n","        offset = 0\n","        x, y = pos\n","\n","        for c in text:\n","            # Write letter\n","            c_size = self.font.getsize(c)\n","            c_image = Image.new('RGBA', c_size, (0, 0, 0, 0))\n","            c_draw = ImageDraw.Draw(c_image)\n","            c_draw.text((0, 0), c, font=self.font, fill=(0, 0, 0, 255))\n","\n","            # Transform\n","            c_image = self._rndLetterTransform(c_image)\n","\n","            # Paste onto image\n","            image.paste(c_image, (x+offset, y), c_image)\n","            offset += c_size[0]\n","\n","    def _drawLine(self, image):\n","        \"\"\"Draw morphed line in Image object.\"\"\"\n","        w, h = image.size\n","        w *= 5\n","        h *= 5\n","\n","        l_image = Image.new('RGBA', (w, h), (0, 0, 0, 0))\n","        l_draw = ImageDraw.Draw(l_image)\n","\n","        x1 = int(w * random.uniform(0, 0.1))\n","        y1 = int(h * random.uniform(0, 1))\n","        x2 = int(w * random.uniform(0.9, 1))\n","        y2 = int(h * random.uniform(0, 1))\n","\n","        # Line width modifier was chosen as an educated guess\n","        # based on default image area.\n","        l_width = round((w * h)**0.5 * 2.284e-2)\n","\n","        # Draw\n","        l_draw.line(((x1, y1), (x2, y2)), fill=(0, 0, 0, 255), width=l_width)\n","\n","        # Transform\n","        l_image = self._rndLineTransform(l_image)\n","        l_image = l_image.resize(image.size, resample=self.resample)\n","\n","        # Paste onto image\n","        image.paste(l_image, (0, 0), l_image)\n","\n","    def _whiteNoise(self, size):\n","        \"\"\"Generate white noise and merge it with given Image object.\"\"\"\n","        if self.noise > 0.003921569:  # 1./255.\n","            w, h = size\n","\n","            pixel = (lambda noise: round(255 * random.uniform(1-noise, 1)))\n","\n","            n_image = Image.new('RGB', size, (0, 0, 0, 0))\n","            rnd_grid = map(lambda _: tuple([pixel(self.noise)]) * 3,\n","                           [0] * w * h)\n","            n_image.putdata(list(rnd_grid))\n","            return n_image\n","        else:\n","            return None\n","\n","    def _rndLetterTransform(self, image):\n","        \"\"\"Randomly morph a single character.\"\"\"\n","        w, h = image.size\n","\n","        dx = w * random.uniform(0.2, 0.5)\n","        dy = h * random.uniform(0.2, 0.5)\n","\n","        x1, y1 = self.__class__._rndPointDisposition(dx, dy)\n","        x2, y2 = self.__class__._rndPointDisposition(dx, dy)\n","\n","        w += abs(x1) + abs(x2)\n","        h += abs(x1) + abs(x2)\n","\n","        quad = self.__class__._quadPoints((w, h), (x1, y1), (x2, y2))\n","\n","        return image.transform(image.size, Image.QUAD,\n","                               data=quad, resample=self.resample)\n","\n","    def _rndLineTransform(self, image):\n","        \"\"\"Randomly morph Image object with drawn line.\"\"\"\n","        w, h = image.size\n","\n","        dx = h * random.uniform(0.2, 0.5)\n","        dy = w * random.uniform(0.2, 0.5)\n","\n","        x1, y1 = [abs(z) for z in self.__class__._rndPointDisposition(dx, dy)]\n","        x2, y2 = [abs(z) for z in self.__class__._rndPointDisposition(dx, dy)]\n","\n","        quad = self.__class__._quadPoints((w, h), (x1, y1), (x2, y2))\n","\n","        return image.transform(image.size, Image.QUAD,\n","                               data=quad, resample=self.resample)\n","\n","    @staticmethod\n","    def _rndPointDisposition(dx, dy):\n","        \"\"\"Return random disposition point.\"\"\"\n","        x = int(random.uniform(-dx, dx))\n","        y = int(random.uniform(-dy, dy))\n","        return (x, y)\n","\n","    @staticmethod\n","    def _quadPoints(size, disp1, disp2):\n","        \"\"\"Return points for QUAD transformation.\"\"\"\n","        w, h = size\n","        x1, y1 = disp1\n","        x2, y2 = disp2\n","\n","        return (\n","            x1,    -y1,\n","            -x1,    h + y2,\n","            w + x2, h - y2,\n","            w - x2, y1\n","        )\n","      \n","##########################################################################################################\n","##########################################################################################################\n","##########################################################################################################\n","#################################### Clapcha Library ends ################################################\n","##########################################################################################################\n","##########################################################################################################\n","##########################################################################################################\n","\n","print (\"test success\")"],"execution_count":2,"outputs":[{"output_type":"stream","text":["test success\n"],"name":"stdout"}]},{"metadata":{"id":"8PTnM6oxGCS6","colab_type":"code","colab":{"autoexec":{"startup":false,"wait_interval":0}}},"cell_type":"code","source":[""],"execution_count":0,"outputs":[]}]}